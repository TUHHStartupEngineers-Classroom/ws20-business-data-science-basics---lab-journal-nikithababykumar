---
title: "Journal (reproducible report)"
author: "Nikitha Baby Kumar"
date: "`r Sys.Date()"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: true
    toc_depth: 3
    #code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	cache = TRUE,
	echo = FALSE
)
```

**IMPORTANT:** You can delete everything in here and start fresh. You might want to start by not deleting anything above this line until you know what that stuff is doing.

This is an `.Rmd` file. It is plain text with special features. Any time you write just like this, it will be compiled to normal text in the website. If you put a \# in front of your text, it will create a top level-header.

# challenge 1 Sales Data analysis

Last compiled: `r Sys.Date()`

Notice that whatever you define as a top level header, automatically gets put into the table of contents bar on the left. 

## Sales by location Image

```{r}
library(tidyverse)
library(readxl)
```

```{r include=FALSE}
# 2.0 Importing Files ----
# A good convention is to use the file name and suffix it with tbl for the data structure tibble
bikes_tbl      <- read_excel(path = "00_data/01_bike_sales/01_raw_data/bikes.xlsx")
orderlines_tbl <- read_excel("00_data/01_bike_sales/01_raw_data/orderlines.xlsx")

# Not necessary for this analysis, but for the sake of completeness
bikeshops_tbl  <- read_excel("00_data/01_bike_sales/01_raw_data/bikeshops.xlsx")
```
```{r include=FALSE}
# If the data has no common column name, you can provide each column name in the "by" argument. For example, by = c("a" = "b") will match x.a to y.b. The order of the columns has to match the order of the tibbles).
left_join(orderlines_tbl, bikes_tbl, by = c("product.id" = "bike.id"))
## # A tibble: 15,644 x 15
##    ...1  order.id order.line order.date          customer.id
##    <chr>    <dbl>      <dbl> <dttm>                    <dbl>
##  1 1            1          1 2015-01-07 00:00:00           2
##  2 2            1          2 2015-01-07 00:00:00           2
##  3 3            2          1 2015-01-10 00:00:00          10
##  4 4            2          2 2015-01-10 00:00:00          10
##  5 5            3          1 2015-01-10 00:00:00           6
##  6 6            3          2 2015-01-10 00:00:00           6
##  7 7            3          3 2015-01-10 00:00:00           6
##  8 8            3          4 2015-01-10 00:00:00           6
##  9 9            3          5 2015-01-10 00:00:00           6
## 10 10           4          1 2015-01-11 00:00:00          22
## # … with 15,634 more rows, and 10 more variables:
## #   product.id <dbl>, quantity <dbl>, model <chr>,
## #   model.year <dbl>, frame.material <chr>, weight <dbl>,
## #   price <dbl>, category <chr>, gender <chr>, url <chr>

# Chaining commands with the pipe and assigning it to order_items_joined_tbl
bike_orderlines_joined_tbl <- orderlines_tbl %>%
        left_join(bikes_tbl, by = c("product.id" = "bike.id")) %>%
        left_join(bikeshops_tbl, by = c("customer.id" = "bikeshop.id"))

# Examine the results with glimpse()
bike_orderlines_joined_tbl %>% glimpse()
## Rows: 15,644
## Columns: 19
## $ ...1           <chr> "1", "2", "3", "4", "5", "6", "7", …
## $ order.id       <dbl> 1, 1, 2, 2, 3, 3, 3, 3, 3, 4, 5, 5,…
## $ order.line     <dbl> 1, 2, 1, 2, 1, 2, 3, 4, 5, 1, 1, 2,…
## $ order.date     <dttm> 2015-01-07, 2015-01-07, 2015-01-10…
## $ customer.id    <dbl> 2, 2, 10, 10, 6, 6, 6, 6, 6, 22, 8,…
## $ product.id     <dbl> 2681, 2411, 2629, 2137, 2367, 1973,…
## $ quantity       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,…
## $ model          <chr> "Spectral CF 7 WMN", "Ultimate CF S…
## $ model.year     <dbl> 2021, 2020, 2021, 2019, 2020, 2020,…
## $ frame.material <chr> "carbon", "carbon", "carbon", "carb…
## $ weight         <dbl> 13.80, 7.44, 14.06, 8.80, 11.50, 8.…
## $ price          <dbl> 3119, 5359, 2729, 1749, 1219, 1359,…
## $ category       <chr> "Mountain - Trail - Spectral", "Roa…
## $ gender         <chr> "female", "unisex", "unisex", "unis…
## $ url            <chr> "https://www.canyon.com/en-de/mount…
## $ name           <chr> "AlexandeRad", "AlexandeRad", "WITT…
## $ location       <chr> "Hamburg, Hamburg", "Hamburg, Hambu…
## $ lat            <dbl> 53.57532, 53.57532, 53.07379, 53.07…
## $ lng            <dbl> 10.015340, 10.015340, 8.826754, 8.8…
```

```{r include=FALSE}
bike_orderlines_joined_tbl %>% 
  select(category) %>%
  filter(str_detect(category, "^Mountain")) %>% 
  unique()
```


```{r include=FALSE}
# 5.0 Wrangling Data ----
# All actions are chained with the pipe already. You can perform each step separately and use glimpse() or View() to validate your code. Store the result in a variable at the end of the steps.
bike_orderlines_wrangled_tbl <- bike_orderlines_joined_tbl %>%
  # 5.1 Separate category name
  separate(col    = location,
           into   = c("city", "state"),
           sep    = ", ") %>%
  
  # 5.2 Add the total price (price * quantity) 
  # Add a column to a tibble that uses a formula-style calculation of other columns
  mutate(total.price = price * quantity) %>%
  
  # 5.3 Optional: Reorganize. Using select to grab or remove unnecessary columns
  # 5.3.1 by exact column name
  select(-...1, -gender) %>%
  
  # 5.3.2 by a pattern
  # You can use the select_helpers to define patterns. 
  # Type ?ends_with and click on Select helpers in the documentation
  select(-ends_with(".id")) %>%
  
  # 5.3.3 Actually we need the column "order.id". Let's bind it back to the data
  bind_cols(bike_orderlines_joined_tbl %>% select(order.id)) %>% 
  
  # 5.3.4 You can reorder the data by selecting the columns in your desired order.
  # You can use select_helpers like contains() or everything()
  select(order.id, contains("order"), contains("model"), contains("category"),
         price, quantity, total.price,
         everything()) %>%
  
  # 5.4 Rename columns because we actually wanted underscores instead of the dots
  # (one at the time vs. multiple at once)
  rename(bikeshop = name) %>%
  set_names(names(.) %>% str_replace_all("\\.", "_"))
```

```{r include=FALSE}
# 6.0 Business Insights ----
# 6.1 Sales by location ----

library(lubridate)
# Step 1 - Manipulate
sales_by_location_tbl <- bike_orderlines_wrangled_tbl %>%
  
  # Select columns
  select(state, total_price) %>%
  
  # Add year column
  #mutate(year = year(order_date)) %>%
  
  # Grouping by state and summarizing sales
  group_by(state) %>% 
  summarize(sales = sum(total_price)) %>%
  
  # Optional: Add a column that turns the numbers into a currency format 
  # (makes it in the plot optically more appealing)
  # mutate(sales_text = scales::dollar(sales)) <- Works for dollar values
  mutate(sales_text = scales::dollar(sales, big.mark = ".", 
                                     decimal.mark = ",", 
                                     prefix = "", 
                                     suffix = " €"))

sales_by_location_tbl
```


```{r plot1, fig.width=10, fig.height=7, echo=FALSE}
library(ggplot2)
library(scales)
  sales_by_location_tbl %>%
    ggplot(aes(x = state, y = sales)) +
    geom_col(fill = "#2DC6D6") + # Use geom_col for a bar plot
  geom_label(aes(label = sales_text)) + # Adding labels to the bars
  geom_smooth(method = "lm", se = FALSE) + # Adding a trendline
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(labels = scales::dollar_format(big.mark = ".", 
                                                    decimal.mark = ",", 
                                                    prefix = "", 
                                                    suffix = " €")) +
     labs(
    title    = "Revenue by location",
    subtitle = "Upward Trend",
    x = "", # Override defaults for x and y
    y = "Revenue"
  )
```


You can add more headers by adding more hashtags. These won't be put into the table of contents

## Sales by year and location Image


```{r include=FALSE}
# 6.2 Sales by Year and location ----
# Step 1 - Manipulate
sales_by_year_loc_tbl <- bike_orderlines_wrangled_tbl %>%
  
  # Select columns and add a year
  select(order_date, total_price, state) %>%
  mutate(year = year(order_date)) %>%
  
  # Group by and summarize year and main catgegory
  group_by(year, state) %>%
  summarise(sales = sum(total_price)) %>%
  ungroup() %>%
  
  # Format $ Text
  mutate(sales_text = scales::dollar(sales, big.mark = ".", 
                                     decimal.mark = ",", 
                                     prefix = "", 
                                     suffix = " €"))

sales_by_year_loc_tbl 
``` 


```{r plot2, fig.width=10, fig.height=7, echo=FALSE}
library(ggplot2)
library(scales)
  sales_by_year_loc_tbl %>%
    ggplot(aes(x = year, y = sales, fill = state)) +
    geom_col() + # Run up to here to get a stacked bar plot
    facet_wrap(~ state) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::dollar_format(big.mark = ".", 
                                                    decimal.mark = ",", 
                                                    prefix = "", 
                                                    suffix = " €")) +
  labs(
    title = "Revenue by year and location",
    subtitle = "Each state has an upward trend",
    fill = "Location" # Changes the legend name
  )
```


Here's an even lower level header

# Challenge 2

Last compiled: `r Sys.Date()`

I'm writing this tutorial going from the top down. And, this is how it will be printed. So, notice the second post is second in the list. If you want your most recent post to be at the top, then make a new post starting at the top. If you want the oldest first, do, then keep adding to the bottom

## get data from API
```{r include=FALSE}
ForecastData <- read.csv("https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/weatherdata/forecast?aggregateHours=1&combinationMethod=aggregate&contentType=csv&unitGroup=metric&locationMode=single&key=FMHYECR8SJR9XCBSBZF7BK2WQ&dataElements=default&locations=Hamburg")

```

```{r echo=FALSE}
as_tibble(ForecastData)
```

## Scapping


```{r include=FALSE}
# 1.1 COLLECT PRODUCT FAMILIES ----

url_home          <- "https://www.canyon.com/en-de"
xopen(url_home) # Open links directly from RStudio to inspect them

# Read in the HTML for the entire webpage
html_home         <- read_html(url_home)

# Web scrape the ids for the families
bike_family_tbl <- html_home %>%
  
  # Get the nodes for the families ...
  html_nodes(css = ".js-navigationDrawer__list--secondary") %>%
  # ...and extract the information of the id attribute
  html_attr('id') %>%
  
  # Remove the product families Gear and Outlet and Woman 
  # (because the female bikes are also listed with the others)
  discard(.p = ~stringr::str_detect(.x,"WMN|WOMEN|GEAR|OUTLET")) %>%
  
  # Convert vector to tibble
  enframe(name = "position", value = "family_class") %>%
  
  # Add a hashtag so we can get nodes of the categories by id (#)
  mutate(
    family_id = str_glue("#{family_class}")
  )

bike_family_tbl
```

```{r include=FALSE}
# 1.2 COLLECT PRODUCT CATEGORIES ----

# Combine all Ids to one string so that we will get all nodes at once
# (seperated by the OR operator ",")
family_id_css <- bike_family_tbl %>%
                    pull(family_id) %>%
                    stringr::str_c(collapse = ", ")
family_id_css
## "#js-navigationList-ROAD, #js-navigationList-MOUNTAIN, #js-navigationList-EBIKES, #js-navigationList-HYBRID-CITY, #js-navigationList-YOUNGHEROES"

# Extract the urls from the href attribute
bike_category_tbl <- html_home %>%

           # Select nodes by the ids
           html_nodes(css = family_id_css) %>%

           # Going further down the tree and select nodes by class
           # Selecting two classes makes it specific enough
           html_nodes(css = ".navigationListSecondary__listItem .js-ridestyles") %>%
           html_attr('href') %>%

           # Convert vector to tibble
           enframe(name = "position", value = "subdirectory") %>%

           # Add the domain, because we will get only the subdirectories
           mutate(
              url = glue("https://www.canyon.com{subdirectory}")
           ) %>%

           # Some categories are listed multiple times.
           # We only need unique values
           distinct(url)

bike_category_tbl
```

```{r include=FALSE}
# 2.0 COLLECT BIKE DATA ----

# 2.1 Get URL for each bike of the Product categories

# select first bike category url
bike_category_url <- bike_category_tbl$url[1]

# Alternatives for selecting values
# bike_category_url <- bike_category_tbl %$% url %>% .[1]
# bike_category_url <- bike_category_tbl %>% pull(url) %>% .[1]
# bike_category_url <- deframe(bike_category_tbl[1,])
# bike_category_url <- bike_category_tbl %>% first %>% first

xopen(bike_category_url)

# Get the URLs for the bikes of the first category
html_bike_category  <- read_html(bike_category_url)
bike_url_tbl        <- html_bike_category %>%

                # Get the 'a' nodes, which are hierarchally underneath 
                # the class productTile__contentWrapper
                html_nodes(css = ".productTile__contentWrapper > a") %>%
                html_attr("href") %>%

                # Remove the query parameters of the URL (everything after the '?')
                str_remove(pattern = "\\?.*") %>%

                # Convert vector to tibble
                enframe(name = "position", value = "url")

# 2.1.2 Extract the descriptions (since we have retrieved the data already)
bike_desc_tbl <- html_bike_category %>%

   # Get the nodes in the meta tag where the attribute itemprop equals description
   html_nodes('.productTile__productSummaryLeft > meta[itemprop="description"]') %>%

   # Extract the content of the attribute content
   html_attr("content") %>%

   # Convert vector to tibble
   enframe(name = "position", value = "description")
```

```{r include=FALSE}
# 2.1.3 Get even more data from JSON files
bike_json_tbl  <- html_bike_category %>%

           html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
           html_attr("data-gtm-impression") %>%

           # Convert the JSON format to dataframe
           # map runs that function on each element of the list
           map(fromJSON) %>% # need JSON ### need lists

           # Extract relevant information of the nested list
           map(purrr::pluck, 2, "impressions") %>% # Need purrr and expl above

           # Set "not defined" and emtpy fields to NA (will be easier to work with)
           map(na_if, "not defined") %>%
           map(na_if, "") %>%

           # The class of dimension56 and price varies between numeric and char.
           # This converts this column in each list to numeric
           # across allows to perform the same operation on multiple columns
           map(~mutate(., across(c("dimension56","price"), as.numeric))) %>%

           # Stack all lists together
           bind_rows() %>%
           # Convert to tibble so that we have the same data format
           as_tibble() %>%

           # Add consecutive numbers so that we can bind all data together
           # You could have also just use bind_cols()
           rowid_to_column(var='position') %>%
           left_join(bike_desc_tbl) %>%
           left_join(bike_url_tbl)
```

```{r include=FALSE}
# 2.2 Wrap it into a function ----
get_bike_data <- function(url) {

  html_bike_category <- read_html(url)

  # Get the URLs
  bike_url_tbl  <- html_bike_category %>%
    html_nodes(css = ".productTile__contentWrapper > a") %>%
    html_attr("href") %>%
    str_remove(pattern = "\\?.*") %>%
    enframe(name = "position", value = "url")

  # Get the descriptions
  bike_desc_tbl <- html_bike_category %>%
    html_nodes(css = '.productTile__productSummaryLeft > 
                      meta[itemprop="description"]') %>%
    html_attr("content") %>%
    enframe(name = "position", value = "description")

  # Get JSON data
  bike_json_tbl <- html_bike_category %>%
             html_nodes(css = '.productGrid__listItem.xlt-producttile > div') %>%
             html_attr("data-gtm-impression") %>%
             map(fromJSON) %>% # need JSON ### need lists
             map(purrr::pluck, 2, "impressions") %>% 
             map(na_if, "not defined") %>%
             map(na_if, "") %>%
             map(~mutate(., across(c("dimension56","price"), as.numeric))) %>%
             bind_rows() %>%
             as_tibble() %>%
             rowid_to_column(var='position') %>%
             left_join(bike_desc_tbl) %>%
             left_join(bike_url_tbl)
}

# Run the function with the first url to check if it is working
bike_category_url <- bike_category_tbl$url[1]
bike_data_tbl     <- get_bike_data(url = bike_category_url)

bike_data_tbl
## # A tibble: 24 x 21
##    position name  id    brand category variant dimension50 dimension51
##                               
##  1        1 Aero… 2881  Cany… Road/Ra… 500119… 2020        Team Repli…
##  2        2 Aero… 2873  Cany… Road/Ra… 500111… 2020        Stealth    
##  3        3 Aero… 2874  Cany… Road/Ra… 500111… 2020        Stealth    
##  4        4 Aero… 2876  Cany… Road/Ra… 500119… 2020        aero silver
##  5        5 Aero… 2875  Cany… Road/Ra… 500118… 2020        Stealth    
##  6        6 Aero… 2877  Cany… Road/Ra… 500119… 2020        Stealth    
##  7        7 Aero… 2878  Cany… Road/Ra… 500119… 2020        Stealth    
##  8        8 Aero… 2225  Cany… Road/Ra… 500042… 2019        Stealth    
##  9        9 Aero… 2096  Cany… Road/Ra… 500008… 2019        Stealth    
## 10       10 Aero… 2091  Cany… Road/Ra… 500007… 2019        Stealth    
## # … with 14 more rows, and 13 more variables: dimension52 ,
## #   dimension53 , dimension54 , dimension55 , dimension63 ,
## #   feedProductId , quantity , price , metric4 ,
## #   dimension56 , metric5 , description , url 

```

```{r include=FALSE}
# 2.3.1a Map the function against all urls

# Extract the urls as a character vector
bike_category_url_vec <- bike_category_tbl %>% 
                            pull(url)

# Run the function with every url as an argument
bike_data_lst <- map(bike_category_url_vec, get_bike_data)

# Merge the list into a tibble
bike_data_tbl <- bind_rows(bike_data_lst)
saveRDS(bike_data_tbl, "bike_data_tbl.rds")

```

```{r include=FALSE}
# 2.3.1b Alternative with a for loop

# Create an empty tibble, that we can populate
bike_data_tbl <- tibble()

# Loop through all urls
for (i in seq_along(bike_category_tbl$url)) {

  bike_category_url <- bike_category_tbl$url[i]
  bike_data_tbl     <- bind_rows(bike_data_tbl, get_bike_data(bike_category_url))

  # Wait between each request to reduce the load on the server 
  # Otherwise we could get blocked
  Sys.sleep(5)

  # print the progress
  print(i)

}
```

```{r include=FALSE}
# Check for duplicates
bike_data_tbl %>%
    group_by(id) %>%
    filter(n()>1) %>%
    arrange(id) %>% 
    View()
```

```{r include=FALSE}
# Filter non Canyon bikes (based on id length) and add an empty column for the colors
bike_data_cleaned_tbl <- bike_data_tbl %>%

    # Filter for bikes. Only unique ones
    filter(nchar(.$id) == 4) %>%
    filter(!(name %>% str_detect("Frameset"))) %>%
    distinct(id, .keep_all = T) %>%

    # Split categories (Speedmax had to be treated individually)
    mutate(category = replace(category, 
           name == "Speedmax CF SLX 8.0 SL", "Road/Triathlon Bike/Speedmax")) %>%
    separate(col = category, into = c("category_1",
                                      "category_2",
                                      "category_3"),
             sep = "(?<!\\s)/(?!\\s)") %>%

    # Renaming
    rename("year"       = "dimension50") %>%
    rename("model"      = "name") %>%
    rename("gender"     = "dimension63") %>%
    rename("price_euro" = "metric4") %>%

    # Fix years manually (have checked the website)
    mutate(year = replace_na(year, 2021)) %>%

    # Add frame material
    mutate(frame_material = case_when(
                          model %>% str_detect(" CF ") ~ "carbon",
                          model %>% str_detect(" CFR ") ~ "carbon",
                          TRUE ~ "aluminium"
                                      )
          ) %>%

    # Select and order columns
    select(-c(position, brand, variant, starts_with("dim"), 
              quantity, feedProductId, price, metric5)) %>%
    select(id, model, year, frame_material, price_euro, everything())

saveRDS(bike_data_cleaned_tbl, "bike_data_cleaned_tbl.rds")
```

```{r include=FALSE}
library(furrr)     # Parallel Processing using purrr (iteration)
plan("multiprocess")
bike_data_colors_tbl <- bike_data_cleaned_tbl %>% 
    mutate(colors = future_map(bike_url_vec, get_colors))
```

```{r include=FALSE}
# 3.2 Create the urls for each variation

bike_data_colors_tbl <- bike_data_colors_tbl %>%

  # Create entry for each color variation
  unnest(colors) %>%

  # Merge url and query parameters for the colors
  mutate(url_color = glue("{url}?dwvar_{id}_pv_rahmenfarbe={colors}")) %>%
  select(-url) %>%

  # Use stringi to replace the last dash with the HTLM format of a dash (%2F)
  # Only if there is a dash in the color column
  mutate(url_color = ifelse(str_detect(colors, pattern = "/"),

                        # if TRUE --> replace      
                        stringi::stri_replace_last_fixed(url_color, "/", "%2F"),

                        # ELSE --> take the original url
                        url_color))

bike_data_colors_tbl %>% glimpse()
## Rows: 416
## Columns: 12
## $ id               <chr> "2493", "2453", "2452", "2452", "2451", "2451",…
## $ model            <chr> "Aeroad CFR Disc EPS", "Aeroad CFR Disc AXS",…
## $ year             <chr> "2020", "2020", "2020", "2020", "2020", …
## $ frame_material   <chr> "carbon", "carbon", "carbon", "carbon", …
## $ price_euro       <chr> "8999.00", "7999.00", "7499.00", "7499.00",…
## $ category_1       <chr> "Road", "Road", "Road", "Road", "Road", …
## $ category_2       <chr> "Race", "Race", "Race", "Race", "Race", …
## $ category_3       <chr> "Aeroad", "Aeroad", "Aeroad", "Aeroad", …
## $ gender           <chr> "unisex", "unisex", "unisex", "unisex", …
## $ description      <chr> "Canyon - An aero road bike that combines …
## $ colors           <chr> "BK/BK", "BK/BK", "BK/BK", "BK/MC", "BK/BK",…
## $ url_color        <chr> "https://www.canyon.com/en-de/road-bikes/…
```

```{r echo=FALSE}
# Create function
get_sizes <- function(url) {

  json <- url %>%

    read_html() %>%

    # Get all 'script nodes' and convert to char
    html_nodes(css = "script") %>%
    as.character() %>%

    # Select the node, that contains 'window.deptsfra'
    str_subset(pattern = "window.deptsfra") %>%

    # remove the chars that do not belong to the json
    # 1. replace at the beginning everything until the first "{" with ""
    str_replace("^[^\\{]+", "") %>%
    # 2. replace at the end everything after the last "}" with ""
    str_replace("[^\\}]+$", "") %>%

    # Convert from json to an r object and pick the relevant values
    fromJSON(flatten = T) %>%
    purrr::pluck("productDetail", "variationAttributes", "values", 2) %>%

    # select(id, value, available, availability)# %>%
    select(id, value, availability.onlyXLeftNumber) %>%

    # Rename
    rename(id_size = id) %>%
    rename(size = value) %>%
    rename(stock_availability = availability.onlyXLeftNumber) %>%

    # Conver to tibble
    as_tibble()

}

# Pull url vector
bike_url_color_vec <- bike_data_colors_tbl %>% 
                        pull(url_color)

# Map
bike_data_sizes_tbl <- bike_data_colors_tbl %>% 
  mutate(size = future_map(bike_url_color_vec, get_sizes))

# Unnest
bike_data_sizes_tbl <- bike_data_sizes_tbl %>% 
                         unnest(size)

saveRDS(bike_data_sizes_tbl, "bike_data_sizes_tbl.rds")
```

